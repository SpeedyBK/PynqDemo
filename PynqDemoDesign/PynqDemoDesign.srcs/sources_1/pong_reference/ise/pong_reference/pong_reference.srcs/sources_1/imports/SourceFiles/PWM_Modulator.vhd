-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Counter is
  generic ( Bits: integer ); 
  port (
    p_out: out std_logic_vector((Bits-1) downto 0);
    ovf: out std_logic;
    C: in std_logic;
    en: in std_logic;
    clr: in std_logic );
end DIG_Counter;

architecture Behavioral of DIG_Counter is
   signal count : std_logic_vector((Bits-1) downto 0) := (others => '0');
begin
    process (C, clr, en)
    begin
      if rising_edge(C) then
        if clr='1' then
          count <= (others => '0');
        elsif en='1' then
          count <= count + 1;
        end if;
      end if;
    end process;

    p_out <= count;
    ovf <= en when count = ((2**Bits)-1) else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    en: in std_logic );
end DIG_Register_BUS;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity COMP_GATE_UNSIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_UNSIGNED;

architecture Behavioral of COMP_GATE_UNSIGNED is
begin
  process(a, b)
  begin
    if (a > b ) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (a < b) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity PWM_Modulator is
  port (
    dds_i: in std_logic_vector(7 downto 0);
    clk_i: in std_logic;
    dds_enable_i : in std_logic;
    reset_i: in std_logic;
    PWM_o: out std_logic;
    enable_o: out std_logic);
end PWM_Modulator;

architecture Behavioral of PWM_Modulator is
  signal s0: std_logic;
  signal s1: std_logic_vector(7 downto 0);
  signal enable_o_temp: std_logic;
  signal s2: std_logic_vector(7 downto 0);
begin
  enable_o_temp <= dds_enable_i;
  gate0: entity work.DIG_Counter
    generic map (
      Bits => 8)
    port map (
      en => enable_o_temp,
      C => clk_i,
      clr => reset_i,
      p_out => s2,
      ovf => s0);
  gate1: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D => dds_i,
      C => clk_i,
      en => s0,
      Q => s1);
  gate2: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 8)
    port map (
      a => s1,
      b => s2,
      gr => PWM_o);
  enable_o <= enable_o_temp;
end Behavioral;
